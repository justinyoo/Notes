# 서버리스 아키텍처 #
serverless-architectures

---
2016년 6월 17일

![](http://martinfowler.com/articles/serverless/mike.jpg)

[마이크 로버츠 Mike Roberts](https://twitter.com/mikebroberts)
마이크는 뉴욕에 사는 엔지니어링 리더이다. 요즘엔 팀 매니지먼트가 주요 업무이긴 하지만 여전히 클로주어 Clojure 쪽에서 코딩도 하고 소프트웨어 아키텍처 쪽에서도 활발한 의견 개진을 하고 있다. 그는 지금 사람들이 서버리스 아키텍처에 대해 주목하는 현상에 대해 꽤 긍정적이다.

아래 태그들을 통해 **비슷한 문서들**을 찾을 수 있다:
[application architecture](http://martinfowler.com/tags/application%20architecture.html)

목차

* [서버리스란 무엇인가?](#what-is-serverless)
  * [몇가지 예제](#a-couple-of-examples)
    * [UI 주도 애플리케이션](#ui-driven-applications)
    * [메시지 주도 애플리케이션](#message-driven-applications)
  * [`Function as a Service` 뒤집어보기](#unpacking-function-as-a-service)
    * 상태
    * 실행 기간
    * 초기 실행 지연
    * API 게이트웨어
    * 도구들
    * 오픈소스
  * 서버리스가 아닌 것은?
    * PaaS와 비교
    * #NoOps
    * Stored Procedures as a Service

---

`서버리스`는 요즘 소프트웨어 아키텍처 세상에서는 아주 핫한 토픽입니다. [책들도](https://leanpub.com/serverless) [나왔고](https://www.amazon.com/gp/product/1680501496?ie=UTF8&tag=martinfowlerc-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=1680501496), [오픈소스 프레임워크도 있고](https://github.com/serverless/serverless), [수많은](https://aws.amazon.com/lambda/) [벤더들이](https://cloud.google.com/functions/docs/) [프레임워크를](https://azure.microsoft.com/en-us/services/functions/) [내놨죠](http://www.ibm.com/cloud-computing/bluemix/openwhisk/). 게다가 아예 `서버리스`만을 주제로 하는 [컨퍼런스](http://serverlessconf.io/)까지 생겼습니다. 그런데, 도대체 `서버리스`가 뭘까요? 그리고 어째서 이 `서버리스`를 고려해야 (혹은 고려하지 말아야) 할까요? 이 [계속 업데이트 되는 문서](http://martinfowler.com/bliki/EvolvingPublication.html)를 통해 저는 당신이 이러한 질문들에 대한 답을 구할 수 있는 빛을 찾기를 바랍니다.


<a name="what-is-serverless"></a>
## 서버리스란 무엇인가? ##

소프트웨어 업계에서 늘상 그렇듯이, `서버리스`에 대한 명확한 관점은 없습니다. 그리고 아래 두 가지의 다르지만 겹치는 부분이 있는 이러한 견해들 역시도요:

1. `서버리스`는 서버단 로직이나 상태 등을 관리하기 위한 써드파티 애플리케이션 혹은 클라우드 서비스에 현저히 또는 온전히 의존하는 애플리케이션들을 설명하기 위해 쓰였습니다. 주로 `리치 클라이언트` 애플리케이션(예를 들자면 단일 페이지 웹 애플리케이션이나 모바일 앱 같은 것들)을 가리키는데, 클라우드에서 접근 가능한 `Parse`나 `Firebase` 같은 데이터베이스라든가, `Auth0`, `AWS Cognito` 같은 인증 서비스들 같은 거대한 생태계를 사용하는 것들입니다. 예전에는 이러한 서비스들을 [(Mobile) Backend as a Service](https://en.wikipedia.org/wiki/Mobile_backend_as_a_service)라고 불렀으니, 여기에서는 이들을 그냥 `BaaS`라고 부르도록 하죠.
2. 또한 `서버리스`는 개발자들이 서버단 로직을 개발자들이 짜긴 하지만, 전통적인 아키텍처와는 달리 상태를 저장하지 않는 Stateless 컴퓨팅 컨테이너에 넣고 돌리는 애플리케이션을 의미하기도 합니다. 이러한 애플리케이션은 보통 이벤트 기반으로 작동하고, 한 번 쓰고 버리고, 써드파티에 의해 관리되죠(ThoughWorks는 최근 [자사 포스트](https://www.thoughtworks.com/radar/techniques/serverless-architecture)에서 이렇게 정의했습니다). 이런 방식으로 생각해 볼 수 있는 한가지 방법은 `[Functions as a Service](https://twitter.com/marak/status/736357543598002176) (or FaaS)`입니다. [AWS 람다](https://aws.amazon.com/lambda/)는 현재 이 FaaS계의 가장 인기있는 구현체지요. 하지만 다른 것들도 더 있습니다. 여기서는 바로 이 `FaaS`를 `서버리스`의 의미로 사용하도록 하겠습니다.

저는 주로 두 번째 얘기를 할텐데요, 조금 더 새롭기도 하고 우리가 흔히 기술적인 아키텍처에 대해 생각하는 것과 현격한 차이가 있기도 합니다. 게다가 요즘 `서버리스`라는 것에 대한 수많은 얘기들이 오고가기 때문이기도 하구요.

하지만, 이러한 개념들이 사실은 모두 관련이 있고 하나로 모여들고 있습니다. [`Auth0`](https://auth0.com/)가 하나의 좋은 예가 될 수 있겠네요. 처음에 BaaS 형태인 `Authentication as a Service`로 시작했다가 지금은 [Auth0 Webtask](https://webtask.io/)를 통해 FaaS 영역으로 들어왔습니다.

게다가 `BaaS 형태의` 애플리케이션을 개발하는 많은 경우, 특히 모바일 앱과 반대로 `리치` 웹 앱을 개발하는 경우, 어느 정도 서버단의 커스텀 기능들이 여전히 필요합니다. 특히 당신이 사용하고 있는 BaaS 서비스와 어느 정도 통합을 한다면 FaaS 가 이런 경우 좋은 솔루션이 될 수 있습니다. 이러한 기능들의 좋은 예로는 데이터 유효성 검사(악성 클라이언트로부터 보호하기 위한)라든가 많은 계산 용량을 필요로 하는 작업들(이미지나 비디오 프로세싱 같은 것들)이 있겠지요.


<a name="a-couple-of-examples"></a>
### 몇 가지 예제 ###

<a name="ui-driven-applications"></a>
#### UI 주도 애플리케이션 ####

서버단에 로직이 있는 전통적인 쓰리티어 클라이언트 시스템을 봅시다. 전자상거래 시스템들 같은 것이 좋은 예가 되겠네요. 예를 달자면 온라인 애완동물 용품 사이트 같은 것.

전통적으로 이런 아키텍처는 이런 식으로 생겼습니다. 서버단에 자바로 구현했고, 클라이언트단에는 HTML과 자바스크립트로 구현하죠.

![](http://martinfowler.com/articles/serverless/ps.svg)

이런 아키텍처에서 클라이언트는 상대적으로 그닥 똑똑하지 않습니다. 대부분의 로직들 &ndash; 인증, 페이지 네비게이션, 검색, 트랜잭션 등은 서버단에서 구현을 해놨으니까요.

`서버리스` 아키텍처에서는 이렇게 보일 겁니다:

![](http://martinfowler.com/articles/serverless/sps.svg)

엄청나게 간단하게 그린 모델인데요, 그럼에도 불구하고 여전히 수많은 변화들이 일어난 것을 볼 수 있습니다. 여기서 잠깐! 이건 단순히 `서버리스` 개념을 보여주기 위한 도구로서 만든 그림이지 이게 이런 식으로 아키텍처를 이전해야 한다고 추천하는 건 아니라는 것을 기억해 두세요!

1. 최초 애플리케이션에서 인증 로직 부분을 빼고 써드파티 BaaS 서비스로 교체했습니다.

2. 또다른 BaaS의 예로, 상품 리스트 출력을 위해서 클라이언트단이 직접 데이터베이스를 접속하게 했습니다. 이 데이터베이스는 AWS의 Dynamo DB 같이 전적으로 써드파티 데이터베이스가 됩니다. 클라이언트단에서 데이터베이스에 접속할 수 있는 다른 보안 프로파일을 적용하는 방식으로 다른 서버 리소스에서도 데이터베이스에 접근할 수 있게도 할 수 있습니다.

3. 앞서 언급한 두 가지 포인트는 굉장히 중요한 이 세번째 포인트를 암시합니다 &ndash; 쇼핑몰 서버단에 있던 로직들이 이제는 클라이언트단으로 옮겨갔다는 거죠. 예를 들자면 사용자 세션 추적이라든가, 페이지 네비게이션 같은 애플리케이션의 UX 구조를 이해하는 로직이라든가 데이터베이스에서 읽어들인 자료를 사용자 뷰에 맞는 형식으로 변환하는 것들이라든가 하는 것들 말입니다. 이렇게 되면 사실 클라이언트단은 이제 [단일 페이지 애플리케이션](https://en.wikipedia.org/wiki/Single-page_application)이 되는 셈입니다.

4. UX관련 기능들중 어떤 것들은 서버단에 계속 두고 싶을 거예요. 예를 들자면 많은 계산 용량을 필요로 한다든가 대용량 데이터에 접근을 해야 한다든가 하는 것들이죠. `검색` 기능을 예로 들 수 있을텐데요, 검색 기능을 위해서 항상 서버를 돌리기 보다는 API 게이트웨이(나중에 다시 설명합니다)를 이용한 FaaS 펑션을 구현해서 HTTP 리퀘스트에 응답하게끔 하면 됩니다. 그렇게 함으로써 우리는 클라이언트단과 서버단에 기능을 두고 상품 데이터가 있는 같은 데이터베이스에서 읽어들이게 할 수 있습니다.

    원래 서버단 기능들을 자바로 구현했고, 이 포스트에서 선택한 FaaS 제공자로서 AWS 람다 서비스를 자바를 지원하기 때문에, 온라인 쇼핑몰의 검색 기능 관련 코드를 서버단에서 람다로 코드를 다시 쓰지 않고도 쉽게 옮길 수 있습니다.

5. 마지막으로 `상품구매` 기능을 다른 FaaS 펑션으로 대체할 수 있습니다. 보안상의 이유로 클라이언트단으로 옮기기 보다는 서버단에 이 기능들을 놓는 것이 낫기 때문입니다. 물론 API 게이트웨이를 그 앞에 놓았습니다.


<a name="message-driven-applications"></a>
#### 메시지 주도 애플리케이션 ####

다른 예를 하나 더 들자면 백엔드에서 돌아가는 데이터 프로세싱 서비스가 될 겁니다. 지금 당신이 사용자 중심의 애플리케이션을 하나 개발하고 있다고 치죠. 이 애플리케이션은 UI 리퀘스트에 재빨리 반응을 해야 합니다. 하지만 동시에 현재 일어나는 모든 종류의 액티비티들을 로그로 저장하고 싶어합니다. 온라인 광고 시스템을 한 번 생각해 봅시다 &ndash; 사용자가 광고를 클릭할 때 사용자를 재빨리 해당 광고의 타겟으로 보내고 싶습니다. 동시에 사용자 클릭이 발생했다는 것을 잡아내서 광고주에게 과금할 수 있어야 합니다.

전통적으로 이런 아키텍처는 보통 `광고 서버`가 동기적으로 사용자에게 반응(여기서는 그 반응이 어떤 것인지에 대해서는 상관하지 않습니다)하는 동시에 채널을 통해 메시지를 보내서 비동기적으로 `클릭 프로세서`를 실행시켜 데이터베이스를 업데이트합니다. 데이터베이스 업데이트에는 광고주 예산에서 광고만큼 금액을 집행하는 것들이 있을 수 있겠죠.

![](http://martinfowler.com/articles/serverless/cp.svg)

그런데, `서버리스` 세상에서는 위의 모델이 아래와 같이 바뀝니다.

![](http://martinfowler.com/articles/serverless/scp.svg)

앞서 예를 든 것과는 차이가 그렇게 많이 나는 것처럼 보이지는 않네요. 우리는 여기서 계속 돌아가는 서버단의 프로세스를 이벤트 주도 형태의 콘텍스트 안에서 돌아가는 FaaS로 바꿨습니다. FaaS 서비스 제공자는 우리에게 서로 연결되어 있는 메시지 브로커(Message Broker)와 FaaS 환경을 제공합니다.

또한 이 FaaS 환경은 동시에 일어나는 클릭들도 펑션 코드를 클릭 이벤트 숫자에 맞게 감지해서 처리합니다. 기존 애플리케이션의 프로세스에 이런 병렬코드 진행 부분이 없었다면 이 새로운 개념을 적용시켜야 할 수도 있습니다.

<a name="unpacking-function-as-a-service"></a>
## `Function as a Service` 뒤집어보기 ##

우리는 이미 FaaS에 대해 여러번 언급을 해 왔습니다. 이제부터는 도대체 그게 뭔지 좀 더 파고 들어갈 때가 됐습니다. 우선 아마존의 람다 서비스에 대한 설명을 좀 보도록 하죠. 번호를 군데군데 매겨놨는데요, 잠시 후에 설명하도록 하겠습니다.

> AWS 람다는 서버를 만든다거나 관리할 필요 없이 당신의 코드를 실행시킬 수 있다. (1) ... 람다와 함께라면 당신은 어떤 형태의 애플리케이션이나 백엔드 서비스에서도 코드를 돌릴 수 있다. (2) &ndash; 관리 비용은 전혀 필요가 없다. 그저 당신의 코드를 업로드하면 람다가 실행에 필요한 모든 것들을 알아서 관리해 주고 (3), 필요하면 스케일링도 해주면서 (4) 계속 높은 가용성을 유지시켜 준다. 당신은 다른 AWS 서비스로부터 자동으로 트리거링을 받게끔 코드를 작성할 수도 있고 (5) 어떤 웹이나 모바일 앱등에서도 이를 직접 호출하여 실행시킬 수 있다. (6)

1. 기본적으로 FaaS는 당신이 서버 시스템들을 관리하지 않으면서도, 당신의 서버 애플리케이션을 통하지 않고서도 백엔드 코드를 실행시키는 것입니다. `서버 애플리케이션`이라는 구절이 다른 현대적인 아키텍처 추세, 도커 컨테이너라든가 PaaS 등과 핵심적인 차이를 만듭니다.

    만약 다시 위의 클릭 처리 예제로 돌아간다면, FaaS가 하는 일은 클릭 처리를 담당하는 서버(물리적 머신으로 실제 그 용도로 쓰이는 그것)를 다른 것 예를 들어 서버 프로비저닝이 필요없는 서버 또는 하루종일 돌아가야 하는 애플리케이션들로 바꾸는 이 바로 FaaS가 할 일들입니다.

2. 